<?php
/**
 * Script pour mettre √† jour le helper IP de Laravel avec la m√™me logique am√©lior√©e
 */

// Inclure les fonctions n√©cessaires
require_once __DIR__ . '/install/config.php';

echo "<!DOCTYPE html>
<html>
<head>
    <title>Mise √† jour Laravel IP Helper - AdminLicence</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        .success { background-color: #d4edda; border-color: #c3e6cb; }
        .warning { background-color: #fff3cd; border-color: #ffeaa7; }
        .error { background-color: #f8d7da; border-color: #f5c6cb; }
        .info { background-color: #d1ecf1; border-color: #bee5eb; }
        .code { background-color: #f8f9fa; padding: 10px; border-radius: 3px; font-family: monospace; white-space: pre-wrap; }
        .btn { display: inline-block; padding: 10px 20px; margin: 5px; background: #007bff; color: white; text-decoration: none; border-radius: 5px; }
        .btn:hover { background: #0056b3; }
    </style>
</head>
<body>
    <h1>üîÑ Mise √† jour Laravel IP Helper</h1>
    <p>Ce script met √† jour le helper IP de Laravel pour utiliser la m√™me logique am√©lior√©e que le syst√®me d'installation.</p>";

// V√©rifier si le fichier Laravel existe
$laravelHelperPath = ROOT_PATH . '/app/Helpers/IPHelper.php';
$helperExists = file_exists($laravelHelperPath);

echo "<div class='section'>
    <h2>üìÅ V√©rification des Fichiers</h2>
    <p><strong>Fichier Laravel IPHelper:</strong> " . ($helperExists ? '‚úÖ Trouv√©' : '‚ùå Non trouv√©') . "</p>
    <p><strong>Chemin:</strong> <code>$laravelHelperPath</code></p>
</div>";

if (isset($_GET['update']) && $_GET['update'] === '1') {
    echo "<div class='section'>
        <h2>üîß Mise √† jour en cours...</h2>";
    
    try {
        // Cr√©er une sauvegarde si le fichier existe
        if ($helperExists) {
            $backupPath = $laravelHelperPath . '.backup.' . date('Y-m-d_H-i-s');
            copy($laravelHelperPath, $backupPath);
            echo "<p>‚úÖ Sauvegarde cr√©√©e: " . basename($backupPath) . "</p>";
        }
        
        // Contenu du nouveau helper Laravel am√©lior√©
        $newLaravelHelper = '<?php

namespace App\Helpers;

/**
 * Classe d\'aide pour la collecte d\'IP du serveur - VERSION AM√âLIOR√âE
 * Synchronis√©e avec le syst√®me d\'installation
 * Mise √† jour automatique le ' . date('Y-m-d H:i:s') . '
 */
class IPHelper
{
    /**
     * Collecte l\'adresse IP r√©elle du serveur de mani√®re robuste
     * 
     * @return array Tableau avec l\'IP s√©lectionn√©e et les d√©tails de diagnostic
     */
    public static function collectServerIP()
    {
        $strategies = [];
        $finalIP = null;
        $finalReason = \'\';
        
        // Strat√©gie 1: Variables serveur classiques avec priorit√©s
        $serverVars = [
            \'SERVER_ADDR\' => $_SERVER[\'SERVER_ADDR\'] ?? null,
            \'HTTP_X_REAL_IP\' => $_SERVER[\'HTTP_X_REAL_IP\'] ?? null,
            \'HTTP_CF_CONNECTING_IP\' => $_SERVER[\'HTTP_CF_CONNECTING_IP\'] ?? null,
            \'HTTP_X_FORWARDED_FOR\' => $_SERVER[\'HTTP_X_FORWARDED_FOR\'] ?? null,
            \'REMOTE_ADDR\' => $_SERVER[\'REMOTE_ADDR\'] ?? null,
            \'HTTP_X_FORWARDED\' => $_SERVER[\'HTTP_X_FORWARDED\'] ?? null,
            \'HTTP_FORWARDED_FOR\' => $_SERVER[\'HTTP_FORWARDED_FOR\'] ?? null,
            \'HTTP_FORWARDED\' => $_SERVER[\'HTTP_FORWARDED\'] ?? null,
            \'HTTP_CLIENT_IP\' => $_SERVER[\'HTTP_CLIENT_IP\'] ?? null,
        ];
        
        foreach ($serverVars as $var => $value) {
            if (!empty($value) && !self::isLocalIP($value)) {
                $strategies[] = [
                    \'method\' => \'server_var\',
                    \'source\' => $var,
                    \'ip\' => $value,
                    \'priority\' => self::getVarPriority($var)
                ];
            }
        }
        
        // Traitement sp√©cial pour HTTP_X_FORWARDED_FOR (peut contenir plusieurs IPs)
        if (!empty($_SERVER[\'HTTP_X_FORWARDED_FOR\'])) {
            $forwardedIPs = explode(\',\', $_SERVER[\'HTTP_X_FORWARDED_FOR\']);
            foreach ($forwardedIPs as $ip) {
                $ip = trim($ip);
                if (!empty($ip) && !self::isLocalIP($ip) && filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE)) {
                    $strategies[] = [
                        \'method\' => \'server_var\',
                        \'source\' => \'HTTP_X_FORWARDED_FOR (premi√®re IP publique)\',
                        \'ip\' => $ip,
                        \'priority\' => 30
                    ];
                    break; // Prendre seulement la premi√®re IP publique
                }
            }
        }
        
        // Strat√©gie 2: R√©solution DNS du hostname
        try {
            $hostname = gethostname();
            if ($hostname !== false) {
                // Utiliser gethostbynamel pour obtenir toutes les IPs
                $hostnameIPs = gethostbynamel($hostname);
                if ($hostnameIPs) {
                    foreach ($hostnameIPs as $ip) {
                        if (!self::isLocalIP($ip)) {
                            $strategies[] = [
                                \'method\' => \'dns_resolution\',
                                \'source\' => \'gethostbynamel(\' . $hostname . \')\',
                                \'ip\' => $ip,
                                \'priority\' => 50
                            ];
                            break; // Prendre seulement la premi√®re IP publique
                        }
                    }
                }
                
                // Fallback avec gethostbyname si gethostbynamel √©choue
                if (empty($strategies)) {
                    $hostnameIP = gethostbyname($hostname);
                    if ($hostnameIP !== $hostname && !self::isLocalIP($hostnameIP)) {
                        $strategies[] = [
                            \'method\' => \'dns_resolution\',
                            \'source\' => \'gethostbyname(\' . $hostname . \')\',
                            \'ip\' => $hostnameIP,
                            \'priority\' => 55
                        ];
                    }
                }
            }
        } catch (\Exception $e) {
            // Ignorer les erreurs DNS
        }
        
        // Strat√©gie 3: Services externes (en dernier recours et seulement si aucune autre m√©thode)
        if (empty($strategies)) {
            $externalServices = [
                \'ipify\' => \'https://api.ipify.org\',
                \'icanhazip\' => \'https://icanhazip.com\'
            ];
            
            foreach ($externalServices as $service => $url) {
                try {
                    $context = stream_context_create([
                        \'http\' => [
                            \'timeout\' => 3,
                            \'user_agent\' => \'AdminLicence-Laravel/1.0\'
                        ]
                    ]);
                    $result = @file_get_contents($url, false, $context);
                    if ($result !== false) {
                        $result = trim($result);
                        if ($result && filter_var($result, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE)) {
                            $strategies[] = [
                                \'method\' => \'external_service\',
                                \'source\' => $service,
                                \'ip\' => $result,
                                \'priority\' => 100
                            ];
                            break; // Prendre seulement le premier service qui fonctionne
                        }
                    }
                } catch (\Exception $e) {
                    // Ignorer les erreurs de service externe
                }
            }
        }
        
        // Trier par priorit√© (plus petit = plus prioritaire)
        usort($strategies, function($a, $b) {
            return $a[\'priority\'] - $b[\'priority\'];
        });
        
        // S√©lectionner la meilleure IP
        if (!empty($strategies)) {
            $best = $strategies[0];
            $finalIP = $best[\'ip\'];
            $finalReason = $best[\'source\'] . \' (\' . $best[\'method\'] . \')\';
        } else {
            // Fallback vers les variables serveur m√™me si locales
            foreach ($serverVars as $var => $value) {
                if (!empty($value)) {
                    $finalIP = $value;
                    $finalReason = $var . \' (fallback)\';
                    break;
                }
            }
            
            // Dernier fallback
            if (!$finalIP) {
                try {
                    $hostname = gethostname();
                    $finalIP = ($hostname !== false) ? gethostbyname($hostname) : \'127.0.0.1\';
                    $finalReason = \'Fallback final\';
                } catch (\Exception $e) {
                    $finalIP = \'127.0.0.1\';
                    $finalReason = \'Fallback final (erreur)\';
                }
            }
        }
        
        return [
            \'ip\' => $finalIP,
            \'reason\' => $finalReason,
            \'sources\' => $serverVars,
            \'strategies\' => $strategies,
            \'is_local\' => self::isLocalIP($finalIP),
            \'is_valid\' => filter_var($finalIP, FILTER_VALIDATE_IP) !== false
        ];
    }

    /**
     * Obtient la priorit√© d\'une variable serveur
     * 
     * @param string $var Nom de la variable
     * @return int Priorit√© (plus petit = plus prioritaire)
     */
    private static function getVarPriority($var)
    {
        $priorities = [
            \'SERVER_ADDR\' => 10,
            \'HTTP_X_REAL_IP\' => 20,
            \'HTTP_CF_CONNECTING_IP\' => 25,
            \'HTTP_X_FORWARDED_FOR\' => 30,
            \'REMOTE_ADDR\' => 40,
            \'HTTP_X_FORWARDED\' => 45,
            \'HTTP_FORWARDED_FOR\' => 46,
            \'HTTP_FORWARDED\' => 47,
            \'HTTP_CLIENT_IP\' => 48
        ];
        return $priorities[$var] ?? 99;
    }

    /**
     * V√©rifie si une IP est consid√©r√©e comme locale/priv√©e
     * 
     * @param string $ip L\'adresse IP √† v√©rifier
     * @return bool True si l\'IP est locale, false sinon
     */
    public static function isLocalIP($ip)
    {
        if (empty($ip)) {
            return true;
        }
        
        // IPs explicitement locales
        $localIPs = [\'127.0.0.1\', \'::1\', \'localhost\'];
        if (in_array($ip, $localIPs)) {
            return true;
        }
        
        // Utiliser les filtres PHP pour d√©tecter les IPs priv√©es/r√©serv√©es
        if (filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE) === false) {
            return true;
        }
        
        return false;
    }

    /**
     * Formate les informations d\'IP pour les logs
     * 
     * @param array $ipInfo R√©sultat de collectServerIP()
     * @return string Message format√© pour les logs
     */
    public static function formatIPInfoForLog($ipInfo)
    {
        $sources = [];
        foreach ($ipInfo[\'sources\'] as $key => $value) {
            $sources[] = "$key: " . ($value ?: \'null\');
        }
        
        $strategiesInfo = \'\';
        if (isset($ipInfo[\'strategies\']) && !empty($ipInfo[\'strategies\'])) {
            $strategiesInfo = \' | Strat√©gies test√©es: \' . count($ipInfo[\'strategies\']);
        }
        
        return "IP s√©lectionn√©e: {$ipInfo[\'ip\']} ({$ipInfo[\'reason\']}) | " . 
               "Local: " . ($ipInfo[\'is_local\'] ? \'oui\' : \'non\') . " | " .
               "Valide: " . ($ipInfo[\'is_valid\'] ? \'oui\' : \'non\') . $strategiesInfo . " | " .
               "Sources: " . implode(\' | \', $sources);
    }

    /**
     * M√©thode de compatibilit√© pour obtenir rapidement l\'IP du serveur
     * 
     * @return string IP du serveur
     */
    public static function getServerIP()
    {
        $result = self::collectServerIP();
        return $result[\'ip\'];
    }

    /**
     * V√©rifie si l\'IP d√©tect√©e est publique
     * 
     * @return bool True si l\'IP est publique, false sinon
     */
    public static function hasPublicIP()
    {
        $result = self::collectServerIP();
        return !$result[\'is_local\'];
    }
}
';
        
        // √âcrire le nouveau fichier
        file_put_contents($laravelHelperPath, $newLaravelHelper);
        
        echo "<div class='success'>
            <h3>‚úÖ Helper Laravel Mis √† Jour</h3>
            <p><strong>Fichier:</strong> app/Helpers/IPHelper.php</p>
            <p><strong>Am√©liorations apport√©es:</strong></p>
            <ul>
                <li>üéØ Logique identique au syst√®me d\'installation</li>
                <li>üîç D√©tection multi-strat√©gies avec priorit√©s</li>
                <li>üåê Services externes en dernier recours</li>
                <li>üìä Logging d√©taill√© des strat√©gies</li>
                <li>‚ö° M√©thodes de compatibilit√© ajout√©es</li>
                <li>üîÑ Synchronisation parfaite entre les syst√®mes</li>
            </ul>
        </div>";
        
        // Test de la nouvelle classe
        if (class_exists(\'App\\Helpers\\IPHelper\')) {
            // Recharger la classe
            include_once $laravelHelperPath;
        }
        
        echo "<div class='info'>
            <h3>üß™ Test de la Nouvelle Classe</h3>
            <p>La classe a √©t√© mise √† jour avec succ√®s. Les m√©thodes disponibles sont :</p>
            <ul>
                <li><code>IPHelper::collectServerIP()</code> - D√©tection compl√®te avec diagnostic</li>
                <li><code>IPHelper::getServerIP()</code> - Obtenir rapidement l\'IP</li>
                <li><code>IPHelper::hasPublicIP()</code> - V√©rifier si l\'IP est publique</li>
                <li><code>IPHelper::isLocalIP($ip)</code> - V√©rifier si une IP est locale</li>
                <li><code>IPHelper::formatIPInfoForLog($info)</code> - Formater pour les logs</li>
            </ul>
        </div>";
        
    } catch (Exception $e) {
        echo "<div class='error'>
            <h3>‚ùå Erreur lors de la Mise √† Jour</h3>
            <p>Erreur: " . $e->getMessage() . "</p>
        </div>";
    }
    
} else {
    echo "<div class='section'>
        <h2>üéØ Actions Disponibles</h2>
        <p>Cette mise √† jour va :</p>
        <ul>
            <li>‚úÖ Synchroniser la logique de d√©tection IP entre l\'installation et Laravel</li>
            <li>üîÑ Remplacer l\'ancienne m√©thode par la nouvelle version am√©lior√©e</li>
            <li>üíæ Cr√©er une sauvegarde de l\'ancien fichier</li>
            <li>üéØ Ajouter des m√©thodes de compatibilit√©</li>
            <li>üìä Am√©liorer le logging et le diagnostic</li>
        </ul>
        <a href='?update=1' class='btn'>üîÑ Mettre √† Jour le Helper Laravel</a>
    </div>";
}

echo "<div class='section'>
    <h2>üìã Informations Importantes</h2>
    <div class='warning'>
        <h3>‚ö†Ô∏è Points √† Retenir</h3>
        <ul>
            <li><strong>Coh√©rence:</strong> Cette mise √† jour assure que l\'installation et Laravel utilisent la m√™me logique</li>
            <li><strong>Compatibilit√©:</strong> Les anciennes m√©thodes restent disponibles</li>
            <li><strong>Performance:</strong> La nouvelle version est optimis√©e et plus robuste</li>
            <li><strong>Logs:</strong> Meilleur diagnostic des probl√®mes de d√©tection IP</li>
        </ul>
    </div>
</div>";

echo "</body></html>";
?>